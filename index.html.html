<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>圆柱体面关系演示 - 飞象老师</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    body { font-family: 'PingFang SC', sans-serif; background-color: #f8fafc; }
    #canvas-container { height: 600px; border-radius: 20px; background: radial-gradient(circle, #ffffff 0%, #f1f5f9 100%); cursor: grab; }
    .glass-panel { background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.5); }
    .slider-thumb::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #0A4737; border-radius: 50%; cursor: pointer; }
  </style>
</head>
<body class="p-4 md:p-8">
  <div class="max-w-6xl mx-auto">
    <div class="flex flex-col md:flex-row justify-between items-end mb-6 gap-4">
      <div>
        <h1 class="text-3xl font-bold text-slate-800">圆柱：从“体”到“面”</h1>
        <p class="text-slate-500 mt-1">保留原始体积线框，观察表面剥离过程</p>
      </div>
      <div class="glass-panel px-4 py-2 rounded-full text-sm font-medium text-emerald-800 shadow-sm">
        知识点：表面积 = 侧面积(2πrh) + 底面积(2πr²)
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
      <!-- 3D 演示区 -->
      <div class="lg:col-span-3 relative">
        <div id="canvas-container" class="shadow-xl border border-slate-200"></div>
        <!-- 悬浮图例 -->
        <div class="absolute bottom-6 left-6 flex gap-4">
          <div class="glass-panel px-3 py-1.5 rounded-lg flex items-center gap-2 text-xs">
            <div class="w-3 h-3 rounded-full bg-emerald-500"></div> <span>侧面</span>
          </div>
          <div class="glass-panel px-3 py-1.5 rounded-lg flex items-center gap-2 text-xs">
            <div class="w-3 h-3 rounded-full bg-orange-500"></div> <span>底面</span>
          </div>
          <div class="glass-panel px-3 py-1.5 rounded-lg flex items-center gap-2 text-xs">
            <div class="w-3 h-3 border border-slate-400 border-dashed"></div> <span>原始体积</span>
          </div>
        </div>
      </div>

      <!-- 控制区 -->
      <div class="flex flex-col gap-6">
        <div class="glass-panel p-6 rounded-3xl shadow-lg">
          <h3 class="font-bold text-slate-700 mb-4 flex items-center gap-2">
            <span class="w-1 h-5 bg-emerald-600 rounded-full"></span> 交互控制
          </h3>
          
          <button id="toggleBtn" class="w-full py-4 bg-emerald-900 hover:bg-emerald-800 text-white rounded-2xl font-bold transition-all shadow-lg active:scale-95 mb-4">
            剥离表面
          </button>
          
          <div class="space-y-5 mt-6">
            <div>
              <div class="flex justify-between text-xs font-bold text-slate-500 mb-2">
                <span>半径 (r)</span>
                <span id="rText" class="text-emerald-700">0.60</span>
              </div>
              <input type="range" id="rSlider" min="0.4" max="0.8" step="0.01" value="0.6" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none slider-thumb">
            </div>
            <div>
              <div class="flex justify-between text-xs font-bold text-slate-500 mb-2">
                <span>高度 (h)</span>
                <span id="hText" class="text-emerald-700">1.40</span>
              </div>
              <input type="range" id="hSlider" min="0.8" max="2.0" step="0.01" value="1.4" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none slider-thumb">
            </div>
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded-3xl text-white shadow-xl">
          <h4 class="text-emerald-400 font-bold mb-3 italic font-serif">Geometry Insight</h4>
          <p class="text-sm leading-relaxed opacity-80">
            注意看：展开后的长方形，它的长度正好包裹了原始圆柱的底面一周。虚线部分代表了圆柱占据的空间体积。
          </p>
          <div class="mt-4 pt-4 border-t border-slate-700 text-xs text-slate-400">
            公式：S = Ch + 2S底
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, controls;
    let sideMesh, topMesh, bottomMesh, ghostCylinder;
    let radius = 0.6, height = 1.4, progress = 0;
    let isExpanded = false;

    function init() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8fafc);

      camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(5, 4, 8);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 0.5);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      createModel();
      animate();
    }

    function createModel() {
      // 清理旧模型
      while(scene.children.length > 2) { 
        scene.remove(scene.children[scene.children.length-1]); 
      }

      // 1. 原始体积“残影” (Ghost Cylinder)
      const ghostGeo = new THREE.CylinderGeometry(radius, radius, height, 32, 1, true);
      const ghostMat = new THREE.MeshBasicMaterial({ 
        color: 0x94a3b8, 
        wireframe: true, 
        transparent: true, 
        opacity: 0.15 
      });
      ghostCylinder = new THREE.Mesh(ghostGeo, ghostMat);
      scene.add(ghostCylinder);

      // 2. 侧面 (剥离面)
      const segments = 128;
      const sideGeo = new THREE.PlaneGeometry(2 * Math.PI * radius, height, segments, 1);
      // 这里的平移是为了让剥离的“轴”位于圆柱的后方边缘
      sideGeo.translate(Math.PI * radius, 0, 0);
      const sideMat = new THREE.MeshPhongMaterial({ 
        color: 0x10b981, 
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 0.8 
      });
      sideMesh = new THREE.Mesh(sideGeo, sideMat);
      
      // 侧面边缘线
      const edgeLines = new THREE.LineSegments(
        new THREE.EdgesGeometry(sideGeo),
        new THREE.LineBasicMaterial({ color: 0x064e3b, opacity: 0.5, transparent: true })
      );
      sideMesh.add(edgeLines);
      scene.add(sideMesh);

      // 3. 底面圆 (剥离圆)
      const capGeo = new THREE.CircleGeometry(radius, 64);
      const capMat = new THREE.MeshPhongMaterial({ color: 0xf97316, side: THREE.DoubleSide });
      
      topMesh = new THREE.Mesh(capGeo, capMat);
      bottomMesh = new THREE.Mesh(capGeo, capMat);
      scene.add(topMesh);
      scene.add(bottomMesh);

      updateAnimation(progress);
    }

    function updateAnimation(p) {
      const circumference = 2 * Math.PI * radius;
      const pos = sideMesh.geometry.attributes.position;
      
      // 侧面剥离逻辑
      // 我们让它绕着 Z 轴（圆柱的一条母线）展开
      // 展开后的平面会向 X 轴正方向平铺，并稍微向外（Z轴正向）偏移以体现“剥离”感
      const peelOffset = p * 0.5; // 剥离时的外移距离

      for (let i = 0; i < pos.count; i++) {
        const x = (i % (128 + 1)) / 128 * circumference;
        const y = pos.getY(i);

        const theta = x / radius;
        
        // 圆柱状态 (处于原位)
        const cylX = Math.sin(theta) * radius;
        const cylZ = Math.cos(theta) * radius;
        
        // 展开状态 (平铺在远处)
        const planX = x;
        const planZ = radius + peelOffset;

        pos.setXYZ(
          i,
          THREE.MathUtils.lerp(cylX, planX, p),
          y,
          THREE.MathUtils.lerp(cylZ, planZ, p)
        );
      }
      pos.needsUpdate = true;

      // 底面圆动画：跟随侧面的中心点移动
      // 侧面中心点在展开后位于 x = C/2, z = radius + peelOffset
      const centerX = THREE.MathUtils.lerp(0, circumference/2, p);
      const centerZ = THREE.MathUtils.lerp(0, radius + peelOffset, p);
      const lift = p * radius; // 向上/下翻开的距离

      topMesh.position.set(centerX, height/2 + lift, centerZ);
      topMesh.rotation.x = THREE.MathUtils.lerp(-Math.PI/2, -Math.PI/4 * p, p); // 稍微倾斜，增加立体感
      if(p > 0.8) topMesh.rotation.x = THREE.MathUtils.lerp(topMesh.rotation.x, 0, (p-0.8)*5);

      bottomMesh.position.set(centerX, -(height/2 + lift), centerZ);
      bottomMesh.rotation.x = THREE.MathUtils.lerp(Math.PI/2, Math.PI/4 * p, p);
      if(p > 0.8) bottomMesh.rotation.x = THREE.MathUtils.lerp(bottomMesh.rotation.x, 0, (p-0.8)*5);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // 交互逻辑
    const toggleBtn = document.getElementById('toggleBtn');
    toggleBtn.onclick = () => {
      isExpanded = !isExpanded;
      toggleBtn.innerText = isExpanded ? "还原圆柱" : "剥离表面";
      gsap.to({v: progress}, {
        v: isExpanded ? 1 : 0,
        duration: 2,
        ease: "expo.inOut",
        onUpdate: function() {
          progress = this.targets()[0].v;
          updateAnimation(progress);
        }
      });
    };

    document.getElementById('rSlider').oninput = (e) => {
      radius = parseFloat(e.target.value);
      document.getElementById('rText').innerText = radius.toFixed(2);
      createModel();
    };

    document.getElementById('hSlider').oninput = (e) => {
      height = parseFloat(e.target.value);
      document.getElementById('hText').innerText = height.toFixed(2);
      createModel();
    };

    window.addEventListener('resize', () => {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    window.onload = init;
  </script>
</body>
</html>